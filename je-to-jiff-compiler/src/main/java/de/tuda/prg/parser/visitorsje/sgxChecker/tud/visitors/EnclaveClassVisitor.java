package de.tuda.prg.parser.visitorsje.sgxChecker.tud.visitors;

import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;
import com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.tuda.prg.parser.visitorsje.sgxChecker.tud.enums.AnnotationEnum;
import de.tuda.prg.parser.visitorsje.sgxChecker.tud.substructures.CompilationUnitMetaDataContainer;
import de.tuda.prg.parser.visitorsje.sgxChecker.tud.substructures.SymbolSolverSingleton;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class extends the VoidVisitorAdapter class and is used to traversal over the AST generated by
 * javaparser. It implements the visit-Method for classes or interfaces. It filters out all classes
 * which are annotated with @Enclave and builds a tree containing information about the usage of
 * fields annotated with @Secret in @Gateway-methods.
 */
public class EnclaveClassVisitor extends VoidVisitorAdapter<CompilationUnitMetaDataContainer> {

    private static final Logger logger = LogManager.getLogger(EnclaveClassVisitor.class);

    /**
     * Is applied on each Node which contains a Class or Interface declaration
     * @param classDeclaration Declaration of class or interface provided by javaparser
     * @param cuMDC Metadata about the compilation unit being analyzed
     */
    @Override
    public void visit(ClassOrInterfaceDeclaration classDeclaration, CompilationUnitMetaDataContainer cuMDC) {

        super.visit(classDeclaration, cuMDC);
        List<MethodCallExpr> methodCallExprs = new ArrayList<>(classDeclaration.findAll(MethodCallExpr.class));

        logger.trace("Checking if Method calls can be resolved through SymbolSolver or are from an external resource");
        this.validateJarCalls(methodCallExprs);

        logger.trace("Checking if Gateway or Secret annotations are used in Non-Enclave classes");
        if(!cuMDC.isEnclaveClass()) {
            this.validateFields(classDeclaration.getFields());
            this.validateMethods(classDeclaration.getMethods());
        }

    }

    /**
     * Check that all fields in a non-enclave class are not @Secret-annotated.
     * @param fields Array of field declarations in class
     */
    private void validateFields(List<FieldDeclaration> fields) {

        List<FieldDeclaration> secretAnnotatedFields = fields.stream().filter(field -> {
            List<AnnotationExpr> fieldAnnotations = field.getAnnotations();
            return fieldAnnotations.toString().contains(AnnotationEnum.SECRET.toString());
        }).collect(Collectors.toList());

        if(!secretAnnotatedFields.isEmpty()) {
            logger.error("@Secret-annotation can only be used in Enclave-classes");
        }
    }

    /**
     * Check that all methods in a non-enclave class are not @Gateway-annotated.
     * @param methods Array of method declarations in class
     */
    private void validateMethods(List<MethodDeclaration> methods) {

        List<MethodDeclaration> gatewayAnnotatedMethods = methods.stream().filter(field -> {
            List<AnnotationExpr> fieldAnnotations = field.getAnnotations();
            return fieldAnnotations.toString().contains(AnnotationEnum.GATEWAY.toString());
        }).collect(Collectors.toList());

        if(!gatewayAnnotatedMethods.isEmpty()) {
            logger.error("@Gateway-annotation can only be used in Enclave-classes");
        }
    }

    /**
     * Check whether method calls can be resolved. If not, the called method is probably from a external resource
     * @param methodCallExprs Method calls performed in the analyzed Class
     */
    private void validateJarCalls(List<MethodCallExpr> methodCallExprs){

        JavaParserFacade symbolSolver = SymbolSolverSingleton.getInstance().getSymbolSolver();

        for(MethodCallExpr methodCallExpr: methodCallExprs){
            SymbolReference<ResolvedMethodDeclaration> maybeMethodDeclaration = symbolSolver.solve(methodCallExpr);
            if(maybeMethodDeclaration.getCorrespondingDeclaration().toAst()!=null){
                if(methodCallExpr.getRange().isPresent()){
                    int line = methodCallExpr.getRange().get().begin.line;
                    logger.warn("[Line: %d] Method %s cant be analyzed. May trigger a @Gateway call."+maybeMethodDeclaration.getCorrespondingDeclaration().getQualifiedName());
                    continue;
                }
                logger.warn("[Missing Line] Method %s cant be analyzed. May trigger a @Gateway call."+maybeMethodDeclaration.getCorrespondingDeclaration().getQualifiedName());
            }
        }
    }

}
