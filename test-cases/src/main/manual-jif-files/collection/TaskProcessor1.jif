import jif.util.*;

public final class TaskProcessor1 [principal Alice, label L] authority (Alice) {

    private Integer{Alice->*; Alice<-*} salary = new Integer(4);

    public Integer{Alice->_; Alice<-*} process{Alice<-*} (List[{}]{} taskList) where authority(Alice) {
        List{Alice<-*} taskListE = endorse(taskList, {} to {Alice<-*});
        Integer result = salary;
        try {
            for (Iterator iter = taskListE.iterator(); iter != null && iter.hasNext();) {
                  Task task =  (Task) iter.next();
                 // result = new Integer(task.run(result));
            }
         }
         catch (NullPointerException e) { }
         catch (ClassCastException e) { }
         catch (NoSuchElementException e) { }
        Integer{Alice->_; Alice<-*}  result1 = declassify(result, {Alice->*; Alice<-*} to {Alice->_; Alice<-*});
        return result1;
    }
}


// This works
/*
public final class TaskProcessor1 [principal Alice, label L] authority (Alice) {

    private Integer{Alice->*; Alice<-*} salary = new Integer(4);

    public Integer{Alice->_; Alice<-*} process{Alice<-*} (List[{}]{} taskList) where authority(Alice) {
        List{{Alice<-*}} taskListE = endorse(taskList, {} to {Alice<-*});
        Integer result = salary;
        try {
            for (Iterator iter = taskListE.iterator(); iter != null && iter.hasNext();) {
                  Task[L] task =  (Task) iter.next();
                  task.run(result);
            }
         }
         catch (NullPointerException e) { }
         catch (ClassCastException e) { }
         catch (NoSuchElementException e) { }
        Integer result1 = declassify(result, {Alice->*; Alice<-*} to {Alice->_; Alice<-*});
        return result1;
    }
}
*/