package Jifs;

public class StatUtil [principal Alice] authority(Alice) {

    // @Secret
    int{Alice->*; Alice<-*} key = 5;

    // @Gateway with parametrized Record
    public Record[Alice]{Alice->_; Alice<-*} process{Alice<-*}(Record[Alice]{Alice->_;Alice<-_}  rec) where authority(Alice) {
        Record recE = endorse(rec, {} to {Alice->*;Alice<-*});
        Record record = decrypt(recE, key);
        Record recResult = endorse(record, {Alice->*;Alice<-_} to {Alice->*;Alice<-*});
        return declassify(recResult, {Alice->*;Alice<-*} to {Alice->_;Alice<-*});
    }

    public Record[Alice]{Alice->*;Alice<-_} decrypt{Alice<-*}(Record[Alice]{Alice->*;Alice<-*} record, int{Alice->*;Alice<-*} offset) {
            // <Top->;U>
            char{*->*;Alice<-_}[] cipher;
            {
                // <Top->;U>
                char{*->*;Alice<-_}[] x = null;
                try {
                    x = record.getData();
                } catch (NullPointerException e) {
                }
                cipher = x;
            }
            int len;
            {
                int y = 0;
                try {
                    y = cipher.length;
                } catch (NullPointerException e) {
                }
                len = y;
            }
            // <Top->;U>
            char{*->*;Alice<-_}[] result = new char[len];
            {
                int in = 0;
                try {
                    in = cipher.length;
                } catch (NullPointerException e) {
                }
                for (int i = 0; i < in; i++) {
                    // <T;U>
                    char{Alice->*; Alice<-*} character;
                    {
                        char r = ' ';
                        try {
                            r = cipher[i];
                        } catch (NullPointerException e) {
                        } catch (ArrayIndexOutOfBoundsException e) {
                        }
                        character = r;
                    }
                    if (character != ' ') {
                        int originalAlphabetPosition = character - 'a';
                        int newAlphabetPosition = (originalAlphabetPosition + offset) % 26;
                        char newCharacter = (char) ('a' + newAlphabetPosition);
                        try {
                            result[i] = newCharacter;
                        } catch (NullPointerException e) {
                        } catch (ArrayIndexOutOfBoundsException e) {
                        }
                    } else {
                        try {
                            result[i] = character;
                        } catch (NullPointerException e) {
                        } catch (ArrayIndexOutOfBoundsException e) {
                        }
                    }
                }
            }
            return new Record[Alice](result);
    }
}
